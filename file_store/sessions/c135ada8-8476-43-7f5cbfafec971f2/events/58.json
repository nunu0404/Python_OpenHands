{"id": 58, "timestamp": "2026-02-02T04:37:15.550420", "source": "agent", "message": "I read the file /workspace/aws-cloudformation__cfn-lint__4c1ccd414732e78587b491543f168571783d7b8e/src/cfnlint/runner.py.", "cause": 57, "observation": "read", "tool_call_metadata": {"function_name": "str_replace_editor", "tool_call_id": "call_534Pv5Sarf1dZhlf984NZbTf", "model_response": {"id": "chatcmpl-D4fyTvWcsei1MyVumwRYa5pjwWuCy", "created": 1770007033, "model": "gpt-4o-2024-08-06", "object": "chat.completion", "system_fingerprint": "fp_4a331a0222", "choices": [{"finish_reason": "tool_calls", "index": 0, "message": {"content": null, "role": "assistant", "tool_calls": [{"function": {"arguments": "{\"command\":\"view\",\"path\":\"/workspace/aws-cloudformation__cfn-lint__4c1ccd414732e78587b491543f168571783d7b8e/src/cfnlint/runner.py\",\"security_risk\":\"LOW\"}", "name": "str_replace_editor"}, "id": "call_534Pv5Sarf1dZhlf984NZbTf", "type": "function"}], "function_call": null, "provider_specific_fields": {"refusal": null}, "annotations": []}, "provider_specific_fields": {}}], "usage": {"completion_tokens": 64, "prompt_tokens": 28904, "total_tokens": 28968, "completion_tokens_details": {"accepted_prediction_tokens": null, "audio_tokens": 0, "reasoning_tokens": 0, "rejected_prediction_tokens": null, "text_tokens": null, "image_tokens": null}, "prompt_tokens_details": {"audio_tokens": 0, "cached_tokens": 1792, "text_tokens": null, "image_tokens": null}}, "service_tier": null}, "total_calls_in_response": 1}, "content": "Here's the result of running `cat -n` on /workspace/aws-cloudformation__cfn-lint__4c1ccd414732e78587b491543f168571783d7b8e/src/cfnlint/runner.py:\n     1\t\"\"\"\n     2\tCopyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n     3\tSPDX-License-Identifier: MIT-0\n     4\t\"\"\"\n     5\t\n     6\tfrom __future__ import annotations\n     7\t\n     8\timport logging\n     9\timport os\n    10\timport sys\n    11\tfrom copy import deepcopy\n    12\tfrom typing import Any, Iterator, Sequence\n    13\t\n    14\timport cfnlint.formatters\n    15\timport cfnlint.maintenance\n    16\tfrom cfnlint.config import ConfigMixIn, configure_logging\n    17\tfrom cfnlint.decode.decode import decode\n    18\tfrom cfnlint.helpers import REGIONS\n    19\tfrom cfnlint.rules import Match, Rules\n    20\tfrom cfnlint.rules.errors import ParseError, TransformError\n    21\tfrom cfnlint.schema import PROVIDER_SCHEMA_MANAGER\n    22\tfrom cfnlint.template.template import Template\n    23\t\n    24\tLOGGER = logging.getLogger(__name__)\n    25\t\n    26\t\n    27\tdef get_formatter(config: ConfigMixIn) -> cfnlint.formatters.BaseFormatter:\n    28\t    \"\"\"\n    29\t    Get a formatter instance based on the specified configuration.\n    30\t\n    31\t    Args:\n    32\t        config (ConfigMixIn): The configuration object containing the format setting.\n    33\t\n    34\t    Returns:\n    35\t        cfnlint.formatters.BaseFormatter: A formatter instance based\n    36\t        on the specified format.\n    37\t\n    38\t    \"\"\"\n    39\t    fmt = config.format\n    40\t    if fmt:\n    41\t        if fmt == \"quiet\":\n    42\t            return cfnlint.formatters.QuietFormatter()\n    43\t        if fmt == \"parseable\":\n    44\t            # pylint: disable=bad-option-value\n    45\t            return cfnlint.formatters.ParseableFormatter()\n    46\t        if fmt == \"json\":\n    47\t            return cfnlint.formatters.JsonFormatter()\n    48\t        if fmt == \"junit\":\n    49\t            return cfnlint.formatters.JUnitFormatter()\n    50\t        if fmt == \"pretty\":\n    51\t            return cfnlint.formatters.PrettyFormatter()\n    52\t        if fmt == \"sarif\":\n    53\t            return cfnlint.formatters.SARIFFormatter()\n    54\t\n    55\t    return cfnlint.formatters.Formatter()\n    56\t\n    57\t\n    58\tclass TemplateRunner:\n    59\t    \"\"\"\n    60\t    Runs a set of rules against a CloudFormation template.\n    61\t\n    62\t    Attributes:\n    63\t        config (ConfigMixIn): The configuration object containing\n    64\t        settings for the template scan.\n    65\t        cfn (Template): The CloudFormation template object.\n    66\t        rules (Rules): The set of rules to be applied to the template.\n    67\t\n    68\t    Methods:\n    69\t        _dedup(matches: Iterator[Match]) -> Iterator[Match]:\n    70\t            Deduplicate a sequence of matches.\n    71\t        run() -> Iterator[Match]:\n    72\t            Run the rules against the CloudFormation template and\n    73\t            yield the resulting matches.\n    74\t        check_metadata_directives(matches: Iterator[Match]) -> Iterator[Match]:\n    75\t            Filter matches based on metadata directives in the template.\n    76\t\n    77\t    \"\"\"\n    78\t\n    79\t    def __init__(\n    80\t        self,\n    81\t        filename: str | None,\n    82\t        template: dict[str, Any],\n    83\t        config: ConfigMixIn,\n    84\t        rules: Rules,\n    85\t    ) -> None:\n    86\t        \"\"\"\n    87\t        Initialize a new TemplateRunner instance.\n    88\t\n    89\t        Args:\n    90\t            filename (str | None): The filename of the CloudFormation template.\n    91\t            template (dict[str, Any]): The CloudFormation template as a dictionary.\n    92\t            config (ConfigMixIn): The configuration object containing\n    93\t            settings for the template scan.\n    94\t            rules (Rules): The set of rules to be applied to the template.\n    95\t        \"\"\"\n    96\t        self.config = deepcopy(config)\n    97\t        self.config.set_template_args(template)\n    98\t        self.cfn = Template(filename, template, self.config.regions)\n    99\t        self.rules = rules\n   100\t\n   101\t    def _dedup(self, matches: Iterator[Match]) -> Iterator[Match]:\n   102\t        \"\"\"\n   103\t        Deduplicate a sequence of matches.\n   104\t\n   105\t        Args:\n   106\t            matches (Iterator[Match]): The sequence of matches to be deduplicated.\n   107\t\n   108\t        Yields:\n   109\t            Match: The unique matches from the input sequence.\n   110\t        \"\"\"\n   111\t        seen: list[Match] = []\n   112\t        for match in matches:\n   113\t            if match not in seen:\n   114\t                seen.append(match)\n   115\t                yield match\n   116\t\n   117\t    def run(self) -> Iterator[Match]:\n   118\t        \"\"\"\n   119\t        Run the rules against the CloudFormation template and\n   120\t        yield the resulting matches.\n   121\t\n   122\t        Yields:\n   123\t            Match: The matches found by running the rules against the template.\n   124\t        \"\"\"\n   125\t        LOGGER.info(\"Run scan of template %s\", self.cfn.filename)\n   126\t        if not set(self.config.regions).issubset(set(REGIONS)):\n   127\t            unsupported_regions = list(\n   128\t                set(self.config.regions).difference(set(REGIONS))\n   129\t            )\n   130\t            raise InvalidRegionException(\n   131\t                (\n   132\t                    f\"Regions {unsupported_regions!r} are unsupported. \"\n   133\t                    f\"Supported regions are {REGIONS!r}\"\n   134\t                ),\n   135\t                32,\n   136\t            )\n   137\t\n   138\t        matches = self.cfn.transform()\n   139\t        if matches:\n   140\t            if self.rules.is_rule_enabled(TransformError(), self.config):\n   141\t                yield from iter(matches)\n   142\t            return\n   143\t\n   144\t        if self.cfn.template is not None:\n   145\t            if self.config.build_graph:\n   146\t                self.cfn.build_graph()\n   147\t            yield from self._dedup(\n   148\t                self.check_metadata_directives(\n   149\t                    self.rules.run(\n   150\t                        filename=self.cfn.filename, cfn=self.cfn, config=self.config\n   151\t                    )\n   152\t                )\n   153\t            )\n   154\t\n   155\t    def check_metadata_directives(self, matches: Iterator[Match]) -> Iterator[Match]:\n   156\t        \"\"\"\n   157\t        Filter matches based on metadata directives in the template.\n   158\t\n   159\t        Args:\n   160\t            matches (Iterator[Match]): The sequence of matches to be filtered.\n   161\t\n   162\t        Yields:\n   163\t            Match: The matches that are not suppressed by metadata directives.\n   164\t        \"\"\"\n   165\t        directives = self.cfn.get_directives()\n   166\t\n   167\t        for match in matches:\n   168\t            if match.rule.id not in directives:\n   169\t                yield match\n   170\t            else:\n   171\t                for mandatory_check in self.config.mandatory_checks:\n   172\t                    if match.rule.id.startswith(mandatory_check):\n   173\t                        yield match\n   174\t                        break\n   175\t                else:\n   176\t                    path = getattr(match, \"path\", None)\n   177\t                    if path:\n   178\t                        if len(path) >= 2:\n   179\t                            if path[0] != \"Resources\":\n   180\t                                yield match\n   181\t                                continue\n   182\t                            if path[1] not in directives[match.rule.id]:\n   183\t                                yield match\n   184\t                        else:\n   185\t                            yield match\n   186\t\n   187\t\n   188\tclass Runner:\n   189\t    \"\"\"\n   190\t    Runs a set of rules against one or more CloudFormation templates.\n   191\t\n   192\t    Attributes:\n   193\t        config (ConfigMixIn): The configuration object containing\n   194\t        settings for the template scan.\n   195\t        formatter (BaseFormatter): The formatter used to output the\n   196\t        results of the template scan.\n   197\t        rules (Rules): The set of rules to be applied to the templates.\n   198\t\n   199\t    Methods:\n   200\t        _get_rules() -> None:\n   201\t            Load the rules to be applied to the templates.\n   202\t        _validate_filenames(filenames: Sequence[str | None]) -> Iterator[Match]:\n   203\t            Validate the specified filenames and yield any matches found.\n   204\t        validate_template(filename: str | None,\n   205\t         template: dict[str, Any]) -> Iterator[Match]:\n   206\t            Validate a single CloudFormation template and yield any matches found.\n   207\t        _cli_output(matches: list[Match]) -> None:\n   208\t            Output the results of the template scan to the console or a file.\n   209\t        _exit(matches: list[Match]) -> int:\n   210\t            Determine the appropriate exit code based on the severity of the matches.\n   211\t        run() -> Iterator[Match]:\n   212\t            Run the template validation process and yield any matches found.\n   213\t        cli() -> None:\n   214\t            Run the template validation process and output the results.\n   215\t    \"\"\"\n   216\t\n   217\t    def __init__(self, config: ConfigMixIn) -> None:\n   218\t        \"\"\"\n   219\t        Initialize a new Runner instance.\n   220\t\n   221\t        Args:\n   222\t            config (ConfigMixIn): The configuration object containing\n   223\t                settings for the template scan.\n   224\t        \"\"\"\n   225\t        self.config = config\n   226\t        self.formatter = get_formatter(self.config)\n   227\t        self.rules: Rules = Rules()\n   228\t        self._get_rules()\n   229\t        # load registry schemas before patching\n   230\t        if self.config.registry_schemas:\n   231\t            for path in self.config.registry_schemas:\n   232\t                PROVIDER_SCHEMA_MANAGER.load_registry_schemas(path)\n   233\t        # now we can patch after loading all registry schemas\n   234\t        if self.config.override_spec:\n   235\t            PROVIDER_SCHEMA_MANAGER.patch(\n   236\t                self.config.override_spec, self.config.regions\n   237\t            )\n   238\t\n   239\t    def _get_rules(self) -> None:\n   240\t        \"\"\"\n   241\t        Load the rules to be applied to the templates.\n   242\t        \"\"\"\n   243\t        self.rules = Rules()\n   244\t        try:\n   245\t            for rules_path in self.config.append_rules:\n   246\t                if rules_path and os.path.isdir(os.path.expanduser(rules_path)):\n   247\t                    self.rules.update(Rules.create_from_directory(rules_path))\n   248\t                else:\n   249\t                    self.rules.update(Rules.create_from_module(rules_path))\n   250\t\n   251\t            self.rules.update(\n   252\t                Rules.create_from_custom_rules_file(self.config.custom_rules)\n   253\t            )\n   254\t        except (OSError, ImportError) as e:\n   255\t            raise UnexpectedRuleException(\n   256\t                f\"Tried to append rules but got an error: {str(e)}\", 1\n   257\t            ) from e\n   258\t\n   259\t    def _validate_filenames(self, filenames: Sequence[str | None]) -> Iterator[Match]:\n   260\t        \"\"\"\n   261\t        Validate the specified filenames and yield any matches found.\n   262\t\n   263\t        This function processes each filename in the provided sequence, decoding the\n   264\t        template and validating it against the configured rules. Any matches found\n   265\t        are yielded as an iterator.\n   266\t\n   267\t        Args:\n   268\t            filenames (Sequence[str | None]): The sequence of filenames to be validated.\n   269\t\n   270\t        Yields:\n   271\t            Match: The matches found during the validation process.\n   272\t\n   273\t        Raises:\n   274\t            None: This function does not raise any exceptions.\n   275\t        \"\"\"\n   276\t        ignore_bad_template: bool = False\n   277\t        if self.config.ignore_bad_template:\n   278\t            ignore_bad_template = True\n   279\t        else:\n   280\t            # There is no collection at this point so we need to handle this\n   281\t            # check directly\n   282\t            if not ParseError().is_enabled(\n   283\t                include_experimental=False,\n   284\t                ignore_rules=self.config.ignore_checks,\n   285\t                include_rules=self.config.include_checks,\n   286\t                mandatory_rules=self.config.mandatory_checks,\n   287\t            ):\n   288\t                ignore_bad_template = True\n   289\t        for filename in filenames:\n   290\t            (template, matches) = decode(filename)\n   291\t            if matches:\n   292\t                if ignore_bad_template or any(\n   293\t                    \"E0000\".startswith(x) for x in self.config.ignore_checks\n   294\t                ):\n   295\t                    matches = [match for match in matches if match.rule.id != \"E0000\"]\n   296\t                    if matches:\n   297\t                        yield from iter(matches)\n   298\t                    return\n   299\t                else:\n   300\t                    yield from iter(matches)\n   301\t                    return\n   302\t            yield from self.validate_template(filename, template)  # type: ignore[arg-type] # noqa: E501\n   303\t\n   304\t    def validate_template(\n   305\t        self, filename: str | None, template: dict[str, Any]\n   306\t    ) -> Iterator[Match]:\n   307\t        \"\"\"\n   308\t        Validate a single CloudFormation template and yield any matches found.\n   309\t\n   310\t        This function takes a CloudFormation template as a dictionary and runs the\n   311\t        configured rules against it. Any matches found are yielded as an iterator.\n   312\t\n   313\t        Args:\n   314\t            filename (str | None): The filename of the CloudFormation template, or\n   315\t                `None` if the template is not associated with a file.\n   316\t            template (dict[str, Any]): The CloudFormation template as a dictionary.\n   317\t\n   318\t        Yields:\n   319\t            Match: The matches found during the validation process.\n   320\t\n   321\t        Raises:\n   322\t            None: This function does not raise any exceptions.\n   323\t        \"\"\"\n   324\t        runner = TemplateRunner(filename, template, self.config, self.rules)\n   325\t        yield from runner.run()\n   326\t\n   327\t    def _cli_output(self, matches: list[Match]) -> None:\n   328\t        formatter = get_formatter(self.config)\n   329\t        matches.sort(key=lambda x: (x.filename, x.linenumber, x.rule.id))\n   330\t        output = formatter.print_matches(matches, self.rules, config=self.config)\n   331\t        if output:\n   332\t            if self.config.output_file:\n   333\t                with open(self.config.output_file, \"w\") as output_file:\n   334\t                    output_file.write(output)\n   335\t            else:\n   336\t                print(output)\n   337\t\n   338\t        self._exit(matches)\n   339\t\n   340\t    def _exit(self, matches: list[Match]) -> int:\n   341\t        \"\"\"Determine exit code\"\"\"\n   342\t\n   343\t        exit_level: str = self.config.non_zero_exit_code or \"informational\"\n   344\t\n   345\t        exit_levels: dict[str, list[str]] = {\n   346\t            \"informational\": [\"informational\", \"warning\", \"error\"],\n   347\t            \"warning\": [\"warning\", \"error\"],\n   348\t            \"error\": [\"error\"],\n   349\t            \"none\": [],\n   350\t        }\n   351\t\n   352\t        exit_code = 0\n   353\t        for match in matches:\n   354\t            if (\n   355\t                match.rule.severity == \"informational\"\n   356\t                and match.rule.severity in exit_levels[exit_level]\n   357\t            ):\n   358\t                exit_code = exit_code | 8\n   359\t            elif (\n   360\t                match.rule.severity == \"warning\"\n   361\t                and match.rule.severity in exit_levels[exit_level]\n   362\t            ):\n   363\t                exit_code = exit_code | 4\n   364\t            elif (\n   365\t                match.rule.severity == \"error\"\n   366\t                and match.rule.severity in exit_levels[exit_level]\n   367\t            ):\n   368\t                exit_code = exit_code | 2\n   369\t\n   370\t        sys.exit(exit_code)\n   371\t\n   372\t    def run(self) -> Iterator[Match]:\n   373\t        \"\"\"\n   374\t        Run the rules against the CloudFormation template and yield\n   375\t        the resulting matches.\n   376\t\n   377\t        This function is responsible for executing the validation\n   378\t        process against the CloudFormation template. It performs\n   379\t        the following steps:\n   380\t\n   381\t        1. Transform the template, if necessary, and yield any matches found.\n   382\t        2. Build the template graph, if configured.\n   383\t        3. Run the configured rules against the template and\n   384\t        yield the resulting matches.\n   385\t        4. Filter the matches based on any metadata directives in the template.\n   386\t        5. Deduplicate the matches before yielding them.\n   387\t\n   388\t        Yields:\n   389\t            Match: The matches found by running the rules against the template.\n   390\t\n   391\t        Raises:\n   392\t            None: This function does not raise any exceptions.\n   393\t        \"\"\"\n   394\t        if not sys.stdin.isatty() and not self.config.templates:\n   395\t            yield from self._validate_filenames([None])\n   396\t            return\n   397\t\n   398\t        yield from self._validate_filenames(self.config.templates)\n   399\t\n   400\t    def cli(self) -> None:\n   401\t        \"\"\"\n   402\t        Run the template validation process and output the results.\n   403\t\n   404\t        This function is the entry point for the command-line interface (CLI) of the\n   405\t        CloudFormation linter.\n   406\t\n   407\t        If no templates are specified and the input is a terminal, the function will\n   408\t        print the usage information and exit with a non-zero status code.\n   409\t\n   410\t        Returns:\n   411\t            None: This function does not return a value.\n   412\t\n   413\t        Raises:\n   414\t            None: This function does not raise any exceptions.\n   415\t        \"\"\"\n   416\t        # Add our logging configuration when running CLI\n   417\t        configure_logging(self.config.debug, self.config.info)\n   418\t\n   419\t        if self.config.update_specs:\n   420\t            cfnlint.maintenance.update_resource_specs(self.config.force)\n   421\t            sys.exit(0)\n   422\t\n   423\t        if self.config.update_iam_policies:\n   424\t            cfnlint.maintenance.update_iam_policies()\n   425\t            sys.exit(0)\n   426\t\n   427\t        if self.config.update_documentation:\n   428\t            # Get ALL rules (ignore the CLI settings))\n   429\t            cfnlint.maintenance.update_documentation(self.rules)\n   430\t            sys.exit(0)\n   431\t\n   432\t        if self.config.listrules:\n   433\t            print(self.rules)\n   434\t            sys.exit(0)\n   435\t\n   436\t        if not self.config.templates:\n   437\t            if sys.stdin.isatty():\n   438\t                self.config.parser.print_help()\n   439\t                sys.exit(1)\n   440\t\n   441\t        try:\n   442\t            self._cli_output(list(self.run(<response clipped><NOTE>Due to the max output limit, only part of this file has been shown to you. You should retry this tool after you have searched inside the file with `grep -n` in order to find the line numbers of what you are looking for.</NOTE>\n", "extras": {"path": "/workspace/aws-cloudformation__cfn-lint__4c1ccd414732e78587b491543f168571783d7b8e/src/cfnlint/runner.py", "impl_source": "oh_aci"}}