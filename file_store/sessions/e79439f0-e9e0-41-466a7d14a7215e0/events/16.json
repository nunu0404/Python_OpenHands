{"id": 16, "timestamp": "2026-02-02T04:34:53.298186", "source": "agent", "message": "I read the file /workspace/aws-cloudformation__cfn-lint__d598742504a6a6af0e5d882b6876f2f30007b851/src/cfnlint/template/template.py.", "cause": 15, "observation": "read", "tool_call_metadata": {"function_name": "str_replace_editor", "tool_call_id": "call_kJopPQw35DtT491z1K9vZkZ4", "model_response": {"id": "chatcmpl-D4fwCFh20aIJFEgU77qFZQJgrMtF4", "created": 1770006892, "model": "gpt-4o-2024-08-06", "object": "chat.completion", "system_fingerprint": "fp_4a331a0222", "choices": [{"finish_reason": "tool_calls", "index": 0, "message": {"content": null, "role": "assistant", "tool_calls": [{"function": {"arguments": "{\"command\":\"view\",\"path\":\"/workspace/aws-cloudformation__cfn-lint__d598742504a6a6af0e5d882b6876f2f30007b851/src/cfnlint/template/template.py\",\"security_risk\":\"LOW\"}", "name": "str_replace_editor"}, "id": "call_kJopPQw35DtT491z1K9vZkZ4", "type": "function"}], "function_call": null, "provider_specific_fields": {"refusal": null}, "annotations": []}, "provider_specific_fields": {}}], "usage": {"completion_tokens": 67, "prompt_tokens": 15036, "total_tokens": 15103, "completion_tokens_details": {"accepted_prediction_tokens": null, "audio_tokens": 0, "reasoning_tokens": 0, "rejected_prediction_tokens": null, "text_tokens": null, "image_tokens": null}, "prompt_tokens_details": {"audio_tokens": 0, "cached_tokens": 0, "text_tokens": null, "image_tokens": null}}, "service_tier": null}, "total_calls_in_response": 1}, "content": "Here's the result of running `cat -n` on /workspace/aws-cloudformation__cfn-lint__d598742504a6a6af0e5d882b6876f2f30007b851/src/cfnlint/template/template.py:\n     1\t\"\"\"\n     2\tCopyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n     3\tSPDX-License-Identifier: MIT-0\n     4\t\"\"\"\n     5\t\n     6\tfrom __future__ import annotations\n     7\t\n     8\timport functools\n     9\timport logging\n    10\tfrom copy import deepcopy\n    11\tfrom typing import TYPE_CHECKING, Any, Iterator\n    12\t\n    13\timport regex as re\n    14\t\n    15\timport cfnlint.conditions\n    16\timport cfnlint.helpers\n    17\tfrom cfnlint._typing import CheckValueFn, Path\n    18\tfrom cfnlint.context import create_context_for_template\n    19\tfrom cfnlint.decode.node import dict_node, list_node\n    20\tfrom cfnlint.graph import Graph\n    21\tfrom cfnlint.match import Match\n    22\tfrom cfnlint.template.getatts import GetAtts\n    23\tfrom cfnlint.template.transforms import Transform\n    24\t\n    25\tif TYPE_CHECKING:\n    26\t    from cfnlint.rules import RuleMatch\n    27\t\n    28\tLOGGER = logging.getLogger(__name__)\n    29\t\n    30\t\n    31\tclass Template:  # pylint: disable=R0904,too-many-lines,too-many-instance-attributes\n    32\t    \"\"\"\n    33\t    Class representing a CloudFormation template.\n    34\t\n    35\t    This class provides methods to access and manipulate various parts of the template,\n    36\t    such as resources, parameters, conditions, and transformations. It also includes\n    37\t    utility methods for checking conditions, resolving references, and more.\n    38\t\n    39\t    Attributes:\n    40\t        regions (list[str]): A list of AWS regions associated with the template.\n    41\t        filename (str | None): The filename of the template file, if available.\n    42\t        template (dict[str, Any]): The dictionary representing the CloudFormation template.\n    43\t        sections (list[str]): A list of CloudFormation template sections.\n    44\t        transform_pre (dict[str, Any]): A dictionary containing pre-processed transformation data.\n    45\t        conditions (Conditions): An instance of the Conditions class used for managing conditions.\n    46\t        graph (Graph): An instance of the Graph class used for representing the template structure.\n    47\t    \"\"\"\n    48\t\n    49\t    def __init__(\n    50\t        self,\n    51\t        filename: str | None,\n    52\t        template: dict[str, Any],\n    53\t        regions: list[str] | None = None,\n    54\t    ):\n    55\t        \"\"\"Initialize a Template instance.\n    56\t\n    57\t        Args:\n    58\t            filename (str | None): The filename of the template file, if available.\n    59\t            template (dict[str, Any]): The dictionary representing the CloudFormation template.\n    60\t            regions (list[str] | None): A list of AWS regions associated with the template.\n    61\t        \"\"\"\n    62\t        if regions is None:\n    63\t            self.regions = [cfnlint.helpers.REGION_PRIMARY]\n    64\t        else:\n    65\t            self.regions = regions\n    66\t        self.filename = filename\n    67\t        self.template = template\n    68\t        self.transform_pre: dict[str, Any] = {}\n    69\t        self.transform_pre[\"Globals\"] = {}\n    70\t        self.transform_pre[\"Ref\"] = self.search_deep_keys(\"Ref\")\n    71\t        self.transform_pre[\"Fn::Sub\"] = self.search_deep_keys(\"Fn::Sub\")\n    72\t        self.transform_pre[\"Fn::FindInMap\"] = self.search_deep_keys(\"Fn::FindInMap\")\n    73\t        self.transform_pre[\"Transform\"] = self.template.get(\"Transform\", [])\n    74\t        self.transform_pre[\"Fn::ForEach\"] = self.search_deep_keys(\n    75\t            cfnlint.helpers.FUNCTION_FOR_EACH\n    76\t        )\n    77\t\n    78\t        self.conditions = cfnlint.conditions.Conditions(self)\n    79\t        self.graph = None\n    80\t        try:\n    81\t            self.graph = Graph(self)\n    82\t        except KeyError as err:\n    83\t            LOGGER.debug(\n    84\t                \"Encountered KeyError error while building graph. Ignored as this \"\n    85\t                \"should be caught by other rules and is more than likely a template \"\n    86\t                \"formatting error: %s\",\n    87\t                err,\n    88\t            )\n    89\t        except Exception as err:  # pylint: disable=broad-except\n    90\t            LOGGER.info(\"Encountered unknown error while building graph: %s\", err)\n    91\t\n    92\t        self.context = create_context_for_template(self)\n    93\t        self.search_deep_keys = functools.lru_cache()(self.search_deep_keys)  # type: ignore\n    94\t\n    95\t    def __deepcopy__(self, memo):\n    96\t        cls = self.__class__\n    97\t        result = cls.__new__(cls)\n    98\t        memo[id(self)] = result\n    99\t        for k, v in self.__dict__.items():\n   100\t            setattr(result, k, deepcopy(v, memo))\n   101\t        return result\n   102\t\n   103\t    def _cache_clear(self):\n   104\t        self.search_deep_keys.cache_clear()\n   105\t\n   106\t    def transform(self) -> list[Match]:\n   107\t        \"\"\"\n   108\t        Transform the template.\n   109\t\n   110\t        Returns:\n   111\t            list[Match]: A list of Match objects representing the transformed template.\n   112\t        \"\"\"\n   113\t        transform = Transform()\n   114\t        results = transform.transform(self)\n   115\t        self._cache_clear()\n   116\t        return results\n   117\t\n   118\t    def build_graph(self) -> None:\n   119\t        \"\"\"Generates a DOT representation of the template\"\"\"\n   120\t        filename = self.filename or \"cfn-lint\"\n   121\t        path = filename + \".dot\"\n   122\t        if not self.graph:\n   123\t            return\n   124\t        try:\n   125\t            self.graph.to_dot(path)\n   126\t            LOGGER.info(\"DOT representation of the graph written to %s\", path)\n   127\t        except ImportError:\n   128\t            LOGGER.error(\n   129\t                (\n   130\t                    \"Could not write the graph in DOT format. \"\n   131\t                    \"Please install either `pygraphviz` or `pydot` modules.\"\n   132\t                )\n   133\t            )\n   134\t\n   135\t    def has_language_extensions_transform(self) -> bool:\n   136\t        \"\"\"Check if the template has the AWS::LanguageExtensions transform declared.\n   137\t\n   138\t        Returns:\n   139\t            bool: True if the AWS::LanguageExtensions transform is declared, False otherwise.\n   140\t        \"\"\"\n   141\t        lang_extensions_transform = \"AWS::LanguageExtensions\"\n   142\t        transform_declaration = self.transform_pre[\"Transform\"]\n   143\t        transform_type = (\n   144\t            transform_declaration\n   145\t            if isinstance(transform_declaration, list)\n   146\t            else [transform_declaration]\n   147\t        )\n   148\t        return bool(lang_extensions_transform in transform_type)\n   149\t\n   150\t    def has_serverless_transform(self) -> bool:\n   151\t        \"\"\"Check if the template has the AWS::Serverless-2016-10-31 transform declared.\n   152\t\n   153\t        Returns:\n   154\t            bool: True if the AWS::Serverless-2016-10-31 transform is declared, False otherwise.\n   155\t        \"\"\"\n   156\t        lang_extensions_transform = \"AWS::Serverless-2016-10-31\"\n   157\t        transform_declaration = self.transform_pre[\"Transform\"]\n   158\t        transform_type = (\n   159\t            transform_declaration\n   160\t            if isinstance(transform_declaration, list)\n   161\t            else [transform_declaration]\n   162\t        )\n   163\t        return bool(lang_extensions_transform in transform_type)\n   164\t\n   165\t    def is_cdk_template(self) -> bool:\n   166\t        \"\"\"Check if the template was created by the AWS Cloud Development Kit (CDK).\n   167\t\n   168\t        Returns:\n   169\t            bool: True if the template was created by CDK, False otherwise.\n   170\t        \"\"\"\n   171\t        resources = self.template.get(\"Resources\")\n   172\t        if not isinstance(resources, dict):\n   173\t            return False\n   174\t\n   175\t        for _, properties in resources.items():\n   176\t            if not isinstance(properties, dict):\n   177\t                continue\n   178\t            resource_type = properties.get(\"Type\")\n   179\t            if not isinstance(resource_type, str):\n   180\t                continue\n   181\t            if resource_type == \"AWS::CDK::Metadata\":\n   182\t                return True\n   183\t\n   184\t        return False\n   185\t\n   186\t    def get_resources(\n   187\t        self, resource_type: list[str] | str = []\n   188\t    ) -> dict[str, dict[str, Any]]:\n   189\t        \"\"\"Get the resources in the template.\n   190\t\n   191\t        Args:\n   192\t            resource_type (list[str] | str): An optional list or string of resource types to filter by.\n   193\t\n   194\t        Returns:\n   195\t            dict[str, dict[str, Any]]: A dictionary containing the resources, where the keys are resource names\n   196\t                and the values are the resource dictionaries.\n   197\t        \"\"\"\n   198\t        resources = self.template.get(\"Resources\", {})\n   199\t        if not isinstance(resources, dict):\n   200\t            return {}\n   201\t        if isinstance(resource_type, str):\n   202\t            resource_type = [resource_type]\n   203\t\n   204\t        results = {}\n   205\t        for k, v in resources.items():\n   206\t            if isinstance(v, dict):\n   207\t                if (v.get(\"Type\", None) in resource_type) or (\n   208\t                    not resource_type and v.get(\"Type\") is not None\n   209\t                ):\n   210\t                    results[k] = v\n   211\t\n   212\t        return results\n   213\t\n   214\t    def get_resource_children(\n   215\t        self, resource_name: str, types: list[str] | None = None\n   216\t    ) -> Iterator[str]:\n   217\t        \"\"\"Get the resource children for a given resource name.\n   218\t\n   219\t        Args:\n   220\t            resource_name (str): The name of the resource.\n   221\t            types (list[str] | None): An optional list of resource types to filter by.\n   222\t\n   223\t        Yields:\n   224\t            str: The name of each resource child.\n   225\t        \"\"\"\n   226\t        types = types or []\n   227\t\n   228\t        if self.graph:\n   229\t            for node_name in self.graph.graph.predecessors(resource_name):\n   230\t                node = self.graph.graph.nodes[node_name]\n   231\t                if node[\"type\"] != \"Resource\":\n   232\t                    continue\n   233\t\n   234\t                if types:\n   235\t                    if node[\"resource_type\"] in types:\n   236\t                        yield node_name\n   237\t                else:\n   238\t                    yield node_name\n   239\t\n   240\t    def get_parameters_valid(self) -> dict[str, dict[str, Any]]:\n   241\t        \"\"\"Get the valid parameters in the template.\n   242\t\n   243\t        Returns:\n   244\t            dict[str, dict[str, Any]]: A dictionary containing the valid parameters, where the keys are parameter names\n   245\t                and the values are the parameter dictionaries.\n   246\t        \"\"\"\n   247\t        result = {}\n   248\t        if isinstance(self.template.get(\"Parameters\"), dict):\n   249\t            parameters = self.template.get(\"Parameters\", {})\n   250\t            for parameter_name, parameter_value in parameters.items():\n   251\t                if isinstance(parameter_value, dict):\n   252\t                    if isinstance(parameter_value.get(\"Type\"), str):\n   253\t                        result[parameter_name] = parameter_value\n   254\t\n   255\t        return result\n   256\t\n   257\t    def get_modules(self) -> dict[str, dict[str, Any]]:\n   258\t        \"\"\"Get the modules in the template.\n   259\t\n   260\t        Returns:\n   261\t            dict[str, dict[str, Any]]: A dictionary containing the modules, where the keys are module names\n   262\t                and the values are the module dictionaries.\n   263\t        \"\"\"\n   264\t        resources = self.template.get(\"Resources\", {})\n   265\t        if not resources:\n   266\t            return {}\n   267\t\n   268\t        results = {}\n   269\t        for k, v in resources.items():\n   270\t            if isinstance(v, dict):\n   271\t                if v.get(\"Type\") is not None and str(v.get(\"Type\")).endswith(\n   272\t                    \"::MODULE\"\n   273\t                ):\n   274\t                    results[k] = v\n   275\t\n   276\t        return results\n   277\t\n   278\t    def get_valid_refs(self) -> cfnlint.helpers.RegexDict:\n   279\t        \"\"\"Get a dictionary of valid references in the template.\n   280\t\n   281\t        Returns:\n   282\t            cfnlint.helpers.RegexDict: A dictionary containing valid references, where the keys are reference names\n   283\t                and the values are dictionaries with information about the reference type and source.\n   284\t        \"\"\"\n   285\t        results = cfnlint.helpers.RegexDict()\n   286\t        parameters = self.template.get(\"Parameters\", {})\n   287\t        if parameters:\n   288\t            for name, value in parameters.items():\n   289\t                if isinstance(value, dict):\n   290\t                    if \"Type\" in value:\n   291\t                        element = {}\n   292\t                        element[\"Type\"] = value[\"Type\"]\n   293\t                        element[\"From\"] = \"Parameters\"\n   294\t                        results[name] = element\n   295\t        resources = self.template.get(\"Resources\", {})\n   296\t        if resources:\n   297\t            for name, value in resources.items():\n   298\t                resource_type = value.get(\"Type\", \"\")\n   299\t                if not isinstance(resource_type, str):\n   300\t                    continue\n   301\t                if resource_type.endswith(\"::MODULE\"):\n   302\t                    element = {}\n   303\t                    element[\"Type\"] = \"MODULE\"\n   304\t                    element[\"From\"] = \"Resources\"\n   305\t                    results[f\"{name}.*\"] = element\n   306\t                elif resource_type:\n   307\t                    element = {}\n   308\t                    element[\"Type\"] = resource_type\n   309\t                    element[\"From\"] = \"Resources\"\n   310\t                    results[name] = element\n   311\t\n   312\t        for pseudoparam in cfnlint.helpers.PSEUDOPARAMS:\n   313\t            element = {}\n   314\t            element[\"Type\"] = \"Pseudo\"\n   315\t            element[\"From\"] = \"Pseudo\"\n   316\t            results[pseudoparam] = element\n   317\t        return results\n   318\t\n   319\t    def get_valid_getatts(self) -> GetAtts:\n   320\t        \"\"\"Get an instance of GetAtts containing valid GetAtt references in the template.\n   321\t\n   322\t        Returns:\n   323\t            GetAtts: An instance of GetAtts containing valid GetAtt references.\n   324\t        \"\"\"\n   325\t        results = GetAtts(self.regions)\n   326\t\n   327\t        for name, value in self.context.resources.items():\n   328\t            results.add(name, value.type)\n   329\t\n   330\t        return results\n   331\t\n   332\t    def get_directives(self) -> dict[str, list[str]]:\n   333\t        \"\"\"Get the directives (ignore_checks) in the template.\n   334\t\n   335\t        Returns:\n   336\t            dict[str, list[str]]: A dictionary containing directives, where the keys are directive names\n   337\t                and the values are lists of resource names associated with the directive.\n   338\t        \"\"\"\n   339\t        results: dict[str, list[str]] = {}\n   340\t        resources = self.get_resources()\n   341\t        if resources:\n   342\t            for resource_name, resource_values in resources.items():\n   343\t                if isinstance(resource_values, dict):\n   344\t                    ignore_rule_ids = (\n   345\t                        resource_values.get(\"Metadata\", {})\n   346\t                        .get(\"cfn-lint\", {})\n   347\t                        .get(\"config\", {})\n   348\t                        .get(\"ignore_checks\", [])\n   349\t                    )\n   350\t                    for ignore_rule_id in ignore_rule_ids:\n   351\t                        if ignore_rule_id not in results:\n   352\t                            results[ignore_rule_id] = []\n   353\t                        results[ignore_rule_id].append(resource_name)\n   354\t        return results\n   355\t\n   356\t    # pylint: disable=dangerous-default-value\n   357\t    def _search_deep_keys(self, searchText: str | re.Pattern, cfndict, path: Path):\n   358\t        \"\"\"Search deep for keys and get their values.\n   359\t\n   360\t        Args:\n   361\t            searchText (str | re.Pattern): The text or regular expression pattern to search for.\n   362\t            cfndict (Any): The dictionary or list to search in.\n   363\t            path (list[Any]): The current path in the dictionary or list.\n   364\t\n   365\t        Returns:\n   366\t            list[list[Any]]: A list of paths where the searchText was found.\n   367\t        \"\"\"\n   368\t        keys = []\n   369\t        if isinstance(cfndict, dict):\n   370\t            for key in cfndict:\n   371\t                pathprop: Path = path[:]\n   372\t                pathprop.append(key)\n   373\t                if isinstance(searchText, str):\n   374\t                    if key == searchText:\n   375\t                        pathprop.append(cfndict[key])\n   376\t                        keys.append(pathprop)\n   377\t                        # pop the last element off for nesting of found elements for\n   378\t                        # dict and list checks\n   379\t                        pathprop = pathprop[:-1]\n   380\t                elif isinstance(searchText, re.Pattern):\n   381\t                    if isinstance(key, str):\n   382\t                        if re.match(searchText, key):\n   383\t                            pathprop.append(cfndict[key])\n   384\t                            keys.append(pathprop)\n   385\t                            # pop the last element off for nesting of found elements for\n   386\t                            # dict and list checks\n   387\t                            pathprop = pathprop[:-1]\n   388\t                if isinstance(cfndict[key], dict):\n   389\t                    keys.extend(\n   390\t                        self._search_deep_keys(searchText, cfndict[key], pathprop)\n   391\t                    )\n   392\t                elif isinstance(cfndict[key], list):\n   393\t                    for index, item in enumerate(cfndict[key]):\n   394\t                        pathproparr = pathprop[:]\n   395\t                        pathproparr.append(index)\n   396\t                        keys.extend(\n   397\t                            self._search_deep_keys(searchText, item, pathproparr)\n   398\t                        )\n   399\t        elif isinstance(cfndict, list):\n   400\t            for index, item in enumerate(cfndict):\n   401\t                pathprop = path[:]\n   402\t                pathprop.append(index)\n   403\t                keys.extend(self._search_deep_keys(searchText, item, pathprop))\n   404\t\n   405\t        return keys\n   406\t\n   407\t    def search_deep_keys(\n   408\t        self, searchText: str | re.Pattern, includeGlobals: bool = True\n   409\t    ):\n   410\t        \"\"\"Search for a key in<response clipped><NOTE>Due to the max output limit, only part of this file has been shown to you. You should retry this tool after you have searched inside the file with `grep -n` in order to find the line numbers of what you are looking for.</NOTE>\n", "extras": {"path": "/workspace/aws-cloudformation__cfn-lint__d598742504a6a6af0e5d882b6876f2f30007b851/src/cfnlint/template/template.py", "impl_source": "oh_aci"}}